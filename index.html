<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoMVCC - Versioning and Consistency Across Databases</title>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <header class="header">
        <table class="width-auto">
            <tr>
                <td class="width-auto">
                    <h1 style="text-transform:inherit !important">TodoMVCC</h1>
                </td>
                <td class="width-min">
                    <a href="https://xtdb.github.io/todomvcc">Demo</a>
                    <a href="https://github.com/xtdb/todomvcc/blob/main/app-spec.md">Spec</a>
                    <a href="https://github.com/xtdb/todomvcc/blob/main/postgres.md">PostgreSQL</a>
                    <a href="https://xtdb.com">XTDB</a>
                </td>
            </tr>
        </table>
    </header>

    <p><strong>TodoMVCC</strong> = like TodoMVC but for databases (not UIs!)</p>

    <p>Developers building data-intensive applications often struggle with versioning, concurrency control, and maintaining consistency over time. Manual versioning schemes, transaction anomalies, and locking contention plague traditional approaches.</p>

    <p>This project demonstrates these challenges using everyone's favorite example: a <strong>todo list</strong>.</p>

    <hr>

    <h2>The Problem</h2>

    <p>Building reliable applications often means wrestling with:</p>

    <ul>
        <li><strong>Manual versioning schemes</strong> - Complex application logic</li>
        <li><strong>Non-serializable transaction anomalies</strong> - Lost updates, phantom reads</li>
        <li><strong>Complex locking strategies</strong> - Deadlocks and contention</li>
        <li><strong>Custom audit trail implementation</strong> - Triggers and history tables</li>
    </ul>

    <p>What if there was a better way?</p>

    <hr>

    <h2>Two Approaches</h2>

    <details>
        <summary>üêò Traditional SQL (PostgreSQL)</summary>
        <p>Manual versioning with locking-based concurrency control.</p>

        <h3>Characteristics:</h3>
        <ul>
            <li>Manual version columns and triggers</li>
            <li>Read committed isolation issues</li>
            <li>Lock contention under load</li>
            <li>Complex audit trail implementation</li>
            <li>Lost update and phantom read anomalies</li>
        </ul>

        <h3>Example Schema:</h3>
        <pre><code>CREATE TABLE todos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT false,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    version BIGINT NOT NULL DEFAULT 1
);

CREATE TABLE todos_history (
    id UUID NOT NULL,
    title TEXT NOT NULL,
    completed BOOLEAN NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL,
    version BIGINT NOT NULL,
    txid BIGINT NOT NULL DEFAULT txid_current(),
    PRIMARY KEY (id, version)
);</code></pre>

        <p><a href="postgres.md">üìñ View Complete PostgreSQL Example ‚Üí</a></p>
    </details>

    <details>
        <summary>üî• XTDB Bitemporal</summary>
        <p>Built-in time dimensions with optimistic concurrency control.</p>

        <h3>Characteristics:</h3>
        <ul>
            <li>Automatic bitemporal versioning</li>
            <li>Serializable transactions by default</li>
            <li>Lock-free optimistic concurrency</li>
            <li>Complete audit trail built-in</li>
            <li>No anomalies, perfect consistency</li>
        </ul>

        <h3>Example Query:</h3>
        <pre><code>-- Time travel query (built-in)
SELECT * FROM todos
FOR SYSTEM_TIME AS OF '2024-01-01T12:00:00Z'
WHERE completed = false;

-- No manual versioning needed!
INSERT INTO todos (id, title, completed)
VALUES (1, 'Learn XTDB', false);</code></pre>

        <p><em>XTDB implementation coming soon...</em></p>
    </details>

    <hr>

    <h2>Interactive Demo</h2>

    <p>The demo will showcase side-by-side comparisons demonstrating:</p>

    <ol>
        <li>Creating todos with different effective dates</li>
        <li>Concurrent updates to the same todo item</li>
        <li>Historical queries to see past states</li>
        <li>Transaction isolation behavior under load</li>
        <li>Manual versioning vs automatic bitemporal tracking</li>
    </ol>

    <p><em>üöß Interactive demo coming soon...</em></p>

    <hr>

    <h2>Real-World Impact</h2>

    <table>
        <thead>
            <tr>
                <th>Challenge</th>
                <th>Traditional SQL</th>
                <th>XTDB Bitemporal</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Version Tracking</strong></td>
                <td>Complex application logic</td>
                <td>Zero application code</td>
            </tr>
            <tr>
                <td><strong>Concurrency</strong></td>
                <td>Deadlocks and timeouts</td>
                <td>No locks, no contention</td>
            </tr>
            <tr>
                <td><strong>Consistency</strong></td>
                <td>Race conditions possible</td>
                <td>Perfect isolation</td>
            </tr>
            <tr>
                <td><strong>Audit Trail</strong></td>
                <td>Manual triggers/tables</td>
                <td>Built-in auditability</td>
            </tr>
            <tr>
                <td><strong>Performance</strong></td>
                <td>Degradation with locking</td>
                <td>Predictable characteristics</td>
            </tr>
        </tbody>
    </table>

    <hr>

    <h2>Implementation Guide</h2>

    <p>Want to contribute an implementation? Check out the <a href="https://github.com/xtdb/todomvcc/blob/main/app-spec.md"><strong>TodoMVCC Specification</strong></a> for guidelines on:</p>

    <ul>
        <li>Core data model requirements</li>
        <li>Required CRUD operations</li>
        <li>Concurrent scenarios to demonstrate</li>
        <li>Directory structure and documentation</li>
    </ul>

    <hr>

    <h2>Educational Use</h2>

    <p>TodoMVCC is perfect for:</p>

    <ul>
        <li><strong>University courses</strong> on database systems and concurrency</li>
        <li><strong>Technical talks</strong> about MVCC and bitemporal databases</li>
        <li><strong>Team training</strong> on data consistency and versioning patterns</li>
        <li><strong>Architecture discussions</strong> about database selection</li>
    </ul>

    <hr>

    <p>
        Built by <a href="https://xtdb.com">XTDB</a> | 
        <a href="https://github.com/xtdb/todomvcc">View on GitHub</a>
    </p>

    <p><em>TodoMVCC combines the familiar TodoMVC concept with Multi-Version Concurrency Control - because sometimes the best way to understand complex database concepts is through a simple, relatable example that every developer knows: a todo list.</em></p>
</body>
</html>
